<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="黄成都的技术博客">
    <meta name="keyword"  content="黄成都, 黄成都的技术博客">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          AFNetWorking源码之AFURLSessionManager - 黄成都的技术博客
        
    </title>

    <link rel="canonical" href="https://github.com/huang303513/huang303513.github.io.git/2017/04/18/AFNetWorking源码之AFURLSessionManager/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="/css/dusign-light.css">

        
<link rel="stylesheet" href="/css/dusign-common-light.css">

        
<link rel="stylesheet" href="/css/font-awesome.css">

        
<link rel="stylesheet" href="/css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="/css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.0"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('snail-bg.jpg')
                /*post*/
            
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#AFNetWorking" title="AFNetWorking">AFNetWorking</a>
                            
                        </div>
                        <h1>AFNetWorking源码之AFURLSessionManager</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by 黄成都 on
                            2017-04-18
                        </span>

                        
                            <div class="blank_box"></div>
                            <span class="meta">
                                Words <span class="post-count">7.3k</span> and
                                Reading Time <span class="post-count">31</span> Minutes
                            </span>
                            <div class="blank_box"></div>
                            <!-- 不蒜子统计 start -->
                            <span class="meta">
                                Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
                            </span>
                            <!-- 不蒜子统计 end -->
                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">黄成都的技术博客</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">Categories</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p><code>AFNetWorking</code>基本上是所有iOS项目的标配。现在升级带最新版的3.X了。得益于苹果从<code>NSURLConnection</code>升级到<code>NSURLSession</code>,AFN也实现了api的简化，同时功能却一点没少。我们来看一下AFN3.X的目录结构：</p>
<ul>
<li>AFNetWorking 这个文件是一个头文件。啥也没做，就是引入了其他文件方便使用。</li>
<li>AFURLSessionManager 这个文件是核心类，基本上通过它来实现了大部分核心功能。负责请求的建立、管理、销毁、安全、请求重定向、请求重启等各种功能。他主要实现了<code>NSURLSession</code>和<code>NSRULSessionTask</code>的封装。</li>
<li>AFHTTPSessionManager 这个文件是<code>AFURLSessionManager</code>的子类。主要实现了对HTTP请求的优化。</li>
<li>AFURLRequestSerialization 这个主要用于请求头的编码解码、序列化、优化处理、简化请求拼接过程等。</li>
<li>AFURLResponseSerialization 这个主要用于网络返回数据的序列化、编码解码、序列化、数据处理等。</li>
<li>AFSecurityPolicy 这个主要用于请求的认证功能。比如https的认证模式等。</li>
<li>AFNetworkReachabilityManager 这个主要用于监听网络请求状态变化功能。</li>
</ul>
<p>首先说明，看AFN源码之前一定要搞清楚<code>NSURLSession</code>系列的api，这样能让你事半功倍，具体可以看<a href="https://huang303513.github.io/2017/04/14/AFNetWorking%E6%BA%90%E7%A0%81%E4%B9%8BNSURLSession%E7%B3%BB%E5%88%97%E6%A6%82%E8%BF%B0.html" target="_blank" rel="noopener">AFNetWorking源码之NSRULSession系列概述</a>。在这篇文章里，我们主要讲解<code>AFURLSessionManager</code>的实现原理和封装过程。首先我们通过一个简单的网络请求看一下他的基本用法(大部分都是非必须的，这里为了掩饰写出来)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)clickButton:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="comment">//通过默认配置初始化Session</span></span><br><span class="line">    <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</span><br><span class="line">    <span class="comment">//设置网络请求序列化对象</span></span><br><span class="line">    AFHTTPRequestSerializer *requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    [requestSerializer setValue:<span class="string">@"test"</span> forHTTPHeaderField:<span class="string">@"requestHeader"</span>];</span><br><span class="line">    requestSerializer.timeoutInterval = <span class="number">60</span>;</span><br><span class="line">    requestSerializer.stringEncoding = <span class="built_in">NSUTF8StringEncoding</span>;</span><br><span class="line">    <span class="comment">//设置返回数据序列化对象</span></span><br><span class="line">    AFHTTPResponseSerializer *responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    manager.responseSerializer = responseSerializer;</span><br><span class="line">    <span class="comment">//网络请求安全策略</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        AFSecurityPolicy *securityPolicy;</span><br><span class="line">        securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey];</span><br><span class="line">        securityPolicy.allowInvalidCertificates = <span class="literal">false</span>;</span><br><span class="line">        securityPolicy.validatesDomainName = <span class="literal">YES</span>;</span><br><span class="line">        manager.securityPolicy = securityPolicy;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        manager.securityPolicy.allowInvalidCertificates = <span class="literal">true</span>;</span><br><span class="line">        manager.securityPolicy.validatesDomainName = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否允许请求重定向</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        [manager setTaskWillPerformHTTPRedirectionBlock:^<span class="built_in">NSURLRequest</span> *(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURLRequest</span> *request) &#123;</span><br><span class="line">            <span class="keyword">if</span> (response) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> request;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听网络状态</span></span><br><span class="line">    [manager.reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,(<span class="keyword">long</span>)status);</span><br><span class="line">    &#125;];</span><br><span class="line">    [manager.reachabilityManager startMonitoring];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:bigPic];</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</span><br><span class="line">    <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [manager downloadTaskWithRequest:request progress:^(<span class="built_in">NSProgress</span> *downloadProgress)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载进度:%lld"</span>,downloadProgress.completedUnitCount);</span><br><span class="line">    &#125; destination:^<span class="built_in">NSURL</span> *(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *documentsDirectoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">NO</span> error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="built_in">NSURL</span> *fileURL = [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"fileURL:%@"</span>,[fileURL absoluteString]);</span><br><span class="line">        <span class="keyword">return</span> fileURL;</span><br><span class="line">    &#125; completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.image = [<span class="built_in">UIImage</span> imageWithData:[<span class="built_in">NSData</span> dataWithContentsOfURL:filePath]];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"File downloaded to: %@"</span>, filePath);</span><br><span class="line">    &#125;];</span><br><span class="line">    [downloadTask resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个请求，我们发现<code>AFURLSessionManager</code>要负责以下几块功能。</p>
<ul>
<li>初始化和管理<code>NSURLSession</code>,通过它来建立和管理各种Task。</li>
<li>初始化和管理<code>NSRULSessionTask</code>,通过不同task来发送不同请求。</li>
<li>管理各种认证功能、安全功能、请求重定向、数据处理。</li>
<li>管理和组织每个task的各种状态管理和通知管理。不同task的回调处理。</li>
<li>帮我们管理和处理了<code>NSRULSession</code>系列api的各种代理方法。简化了我们的处理。</li>
</ul>
<h2 id="2-AFURLSessionManager的声明分析"><a href="#2-AFURLSessionManager的声明分析" class="headerlink" title="2 AFURLSessionManager的声明分析"></a>2 AFURLSessionManager的声明分析</h2><p> <code>AFURLSessionManager</code>根据一个指定的<code>NSURLSessionConfiguration</code>创建和管理一个<code>NSURLSession</code>对象。并且这个对象实现了<code>&lt;NSURLSessionTaskDelegate&gt;</code>, <code>&lt;NSURLSessionDataDelegate&gt;</code>, <code>&lt;NSURLSessionDownloadDelegate&gt;</code>, 和 <code>&lt;NSURLSessionDelegate&gt;</code>这几个协议的协议方法。同时实现<code>NSSecureCoding</code>和<code>NSCopying</code>来实现归档解档和copy功能。</p>
<h4 id="2-1-AFURLSessionManager的初始化api"><a href="#2-1-AFURLSessionManager的初始化api" class="headerlink" title="2.1 AFURLSessionManager的初始化api"></a>2.1 <code>AFURLSessionManager</code>的初始化api</h4><p>这些api主要用于初始化、安全策略、网络状态监听等:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface AFURLSessionManager : <span class="built_in">NSObject</span> &lt;<span class="built_in">NSURLSessionDelegate</span>, <span class="built_in">NSURLSessionTaskDelegate</span>, <span class="built_in">NSURLSessionDataDelegate</span>, <span class="built_in">NSURLSessionDownloadDelegate</span>, <span class="built_in">NSSecureCoding</span>, <span class="built_in">NSCopying</span>&gt;</span><br><span class="line"><span class="comment">//指定的初始化方法、通过他来初始化一个Manager对象。</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionConfiguration</span> *)configuration </span><br><span class="line"><span class="comment">//AFURLSessionManager通过session来管理和创建网络请求。一个manager就实现了对这个session的管理，他们是一一对应的关系。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSession</span> *session;</span><br><span class="line"><span class="comment">//处理网络请求回调的操作队列,就是我们初始化session的时候传入的那个OperationQueue参数。如果不传入，默认是MainOperationQueue。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOperationQueue</span> *operationQueue;</span><br><span class="line"><span class="comment">//对返回数据的处理都通过这个属性来处理，比如数据的提取、转换等。默认是一个`AFJSONResponseSerializer`对象用JSON的方式解析。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> &lt;AFURLResponseSerialization&gt; responseSerializer;</span><br><span class="line"><span class="comment">//用于指定session的安全策略。用于处理信任主机和证书认证等。默认是`defaultPolicy`。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFSecurityPolicy *securityPolicy;</span><br><span class="line"><span class="comment">//观测网络状态的变化，具体可以看我的Demo用法。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFNetworkReachabilityManager *reachabilityManager;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-AFURLSessionManager获取Task的api"><a href="#2-2-AFURLSessionManager获取Task的api" class="headerlink" title="2.2 AFURLSessionManager获取Task的api"></a>2.2 <code>AFURLSessionManager</code>获取Task的api</h4><p> 这部分api主要是任务的创建、任务的分类、任务完成队列处理、特殊情况的任务重新创建等：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前session创建的所有Task，这个是下面三种task的总和。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionTask</span> *&gt; *tasks;</span><br><span class="line"><span class="comment">//当前session创建的DataTask</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionDataTask</span> *&gt; *dataTasks;</span><br><span class="line"><span class="comment">//当前session创建的uploadTask</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionUploadTask</span> *&gt; *uploadTasks;</span><br><span class="line"><span class="comment">//当前session创建的downloadTask</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionDownloadTask</span> *&gt; *downloadTasks;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于处理任务回调的GCD对象，默认是dispatch_main_queue。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> completionQueue;</span><br><span class="line"><span class="comment">//用于处理任务回调的GCD的group对象，如果不初始化、则一个默认的Group被使用。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) dispatch_group_t completionGroup;</span><br><span class="line"><span class="comment">//在iOS7的环境下，我们通过background模式的session创建的uploadTask有时会是nil，如果这个属性是yes，AFN会尝试再次创建uploadTask。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> attemptsToRecreateUploadTasksForBackgroundSessions;</span><br><span class="line"><span class="comment">//废除manager对应的Session。通过传入的参数来决定是否立即取消已经用session发出去的任务。</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidateSessionCancelingTasks:(<span class="built_in">BOOL</span>)cancelPendingTasks;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-AFURLSessionManager为管理Task创建Block"><a href="#2-3-AFURLSessionManager为管理Task创建Block" class="headerlink" title="2.3 AFURLSessionManager为管理Task创建Block"></a>2.3 <code>AFURLSessionManager</code>为管理Task创建Block</h4><p><code>AFURLSessionManager</code>提供了很多创建Task的api。并且提供了很多处理Task的Block。应该说着几个api就是AFN为我们提供的最大价值，他把所有delegate方法细节都处理好。直接提供给我们一些最实用的api，我们就不用去管理session系列繁琐的delegate方法了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个NSURLSessionDataTask</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"><span class="comment">//创建一个NSURLSessionDataTask,并且能获取上传或者下载进度</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个上传Task，并且指定上传文件的路径。</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                         fromFile:(<span class="built_in">NSURL</span> *)fileURL</span><br><span class="line">                                         progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class="line">                                completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject, <span class="built_in">NSError</span>  * _Nullable error))completionHandler;</span><br><span class="line"><span class="comment">////创建一个上传Task，并且指定上传的数据。</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                         fromData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)bodyData</span><br><span class="line">                                         progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class="line">                                completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"><span class="comment">//创建一个uploadTask，然后上传数据</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithStreamedRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                                 progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgressBlock</span><br><span class="line">                                        completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"><span class="comment">//新建一个download任务，destination表示的下载文件的缓存路径</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                             progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class="line">                                          destination:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">                                    completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"><span class="comment">//继续恢复一个download任务。resumeData参数表示的是恢复下载的时候初始化数据，比如前面已经下载好的部分数据。</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class="built_in">NSData</span> *)resumeData</span><br><span class="line">                                                progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class="line">                                             destination:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">                                       completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"><span class="comment">//获取指定Task的上传进度</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSProgress</span> *)uploadProgressForTask:(<span class="built_in">NSURLSessionTask</span> *)task;</span><br><span class="line"><span class="comment">//获取指定Task的下载进度</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSProgress</span> *)downloadProgressForTask:(<span class="built_in">NSURLSessionTask</span> *)task;</span><br></pre></td></tr></table></figure>
<p>注意：上面所有Task的progress都不在主线程、所以要在progress中做UI更新，都必须手动在主线程操作。</p>
<h4 id="2-4-AFURLSessionManager设置各种情况的代理回调"><a href="#2-4-AFURLSessionManager设置各种情况的代理回调" class="headerlink" title="2.4 AFURLSessionManager设置各种情况的代理回调"></a>2.4 <code>AFURLSessionManager</code>设置各种情况的代理回调</h4><p>这些回调Block主要是用于处理网络请求过程或者结束以后的数据处理、认证、通知、缓存等。我们可以通过设置这些Block来获取或者检测各种状态。相当于就是钩子函数。通过下面的这些Block，我们基本可以获取请求过程中的所有状态以及需要做的各种处理。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置Session出错或者无效的手的回调Block。这个Block主要在`NSURLSessionDelegate`代理的`URLSession:didBecomeInvalidWithError:`方法中执行。</span></span><br><span class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当网络请需要的认证信息比如用户名密码已经发送了的时候，就可以通过这个Block来处理。这个Block是在`NSURLSessionDelegate`代理里面的`URLSession:didReceiveChallenge:completionHandler:`方法中被执行。注意这个是针对Session</span></span><br><span class="line">- (<span class="keyword">void</span>)setSessionDidReceiveAuthenticationChallengeBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionAuthChallengeDisposition</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLAuthenticationChallenge</span> *challenge, <span class="built_in">NSURLCredential</span> * _Nullable __autoreleasing * _Nullable credential))block&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////当网络请需要的认证信息比如用户名密码已经发送了的时候，就可以通过这个Block来处理。这个Block是在`NSURLSessionTaskDelegate`代理里面的`URLSession:task:didReceiveChallenge:completionHandler:`方法中被执行。注意这个是针对Task。</span></span><br><span class="line">- (<span class="keyword">void</span>)setTaskDidReceiveAuthenticationChallengeBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionAuthChallengeDisposition</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSURLAuthenticationChallenge</span> *challenge, <span class="built_in">NSURLCredential</span> * _Nullable __autoreleasing * _Nullable credential))block&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当请求需要一个新的bodystream的时候，就可以通过这个Block来设置。这个Block在`NSURLSessionTaskDelegate` 代理协议的`URLSession:task:needNewBodyStream:`方法里面设置。</span></span><br><span class="line">- (<span class="keyword">void</span>)setTaskNeedNewBodyStreamBlock:(<span class="keyword">nullable</span> <span class="built_in">NSInputStream</span> * (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task))block&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当一个网络请求需要重定向的时候。就会调用这个Block。这个Block是在`NSURLSessionTaskDelegate`协议的`URLSession:willPerformHTTPRedirection:newRequest:completionHandler:`方法中调用的。</span></span><br><span class="line">- (<span class="keyword">void</span>)setTaskWillPerformHTTPRedirectionBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> * (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURLRequest</span> *request))block&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以通过设置这个Block来获取上传进度。这个Block主要在`NSURLSessionTaskDelegate`协议的 `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`方法中调用.</span></span><br><span class="line">- (<span class="keyword">void</span>)setTaskDidSendBodyDataBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置一个Task完成以后执行的Block，这个Block在`NSURLSessionTaskDelegate`协议的 `URLSession:task:didCompleteWithError:`方法中执行。</span></span><br><span class="line">- (<span class="keyword">void</span>)setTaskDidCompleteBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionTask</span> *task, <span class="built_in">NSError</span> * _Nullable error))block&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当接收到网络请求返回以后，可以调用这个Block。这个Block是在`NSURLSessionDataDelegate`协议的 `URLSession:dataTask:didReceiveResponse:completionHandler:`</span></span><br><span class="line">- (<span class="keyword">void</span>)setDataTaskDidReceiveResponseBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionResponseDisposition</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSURLResponse</span> *response))block&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果一个dataTask转换为downLoadTask以后，就可以设置这个Block来调用。在`NSURLSessionDataDelegate` 协议的`URLSession:dataTask:didBecomeDownloadTask:`方法中调用。</span></span><br><span class="line">- (<span class="keyword">void</span>)setDataTaskDidBecomeDownloadTaskBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask))block&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当dataTask接收到数据以后，可以设置调用这个Block。具体在`NSURLSessionDataDelegate`协议的`URLSession:dataTask:didReceiveData:`方法。</span></span><br><span class="line">- (<span class="keyword">void</span>)setDataTaskDidReceiveDataBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSData</span> *data))block&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置一个Block来决定是否处理或者换成网络请求缓存。具体在`NSURLSessionDataDelegate`协议的`URLSession:dataTask:willCacheResponse:completionHandler:`方法中。</span></span><br><span class="line">- (<span class="keyword">void</span>)setDataTaskWillCacheResponseBlock:(<span class="keyword">nullable</span> <span class="built_in">NSCachedURLResponse</span> * (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDataTask</span> *dataTask, <span class="built_in">NSCachedURLResponse</span> *proposedResponse))block&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当session所有的任务都发送出去以后，就可以通过这个Block来获取。具体在`NSURLSessionDataDelegate`协议的 `URLSessionDidFinishEventsForBackgroundURLSession:`方法中。</span></span><br><span class="line">- (<span class="keyword">void</span>)setDidFinishEventsForBackgroundURLSessionBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session))block&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当一个downloadTask执行完毕以后，可以通过这个Block来获取下载信息，我们可以通过这个Block获取下载文件的位置。具体在`NSURLSessionDownloadDelegate`协议的`URLSession:downloadTask:didFinishDownloadingToURL:`方法中被调用。</span></span><br><span class="line">- (<span class="keyword">void</span>)setDownloadTaskDidFinishDownloadingBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> * _Nullable  (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask, <span class="built_in">NSURL</span> *location))block&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以通过这个Block获取一个downloadTask的下载进度。这个Block会在下载过程中多次被调用。具体是在`NSURLSessionDownloadDelegate`协议中的`URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite:`方法中被调用。</span></span><br><span class="line">- (<span class="keyword">void</span>)setDownloadTaskDidWriteDataBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当一个downloadTask重新开始以后，我们可以通过这个Block获取fileOffSet等信息获取已经下载的部分以及总共有多少要下载。具体是在`NSURLSessionDownloadDelegate`协议的`URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`方法中被调用。</span></span><br><span class="line">- (<span class="keyword">void</span>)setDownloadTaskDidResumeBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上面的部分，<code>AFURLSessionManager</code>的头文件还提供了很多<code>notification</code>的声明。通过这些通知，我们可以获取Task是否开始、是否完成、是否挂起、是否无效等各种通知。具体可以去文件里看。</p>
<h2 id="3-AFURLSessionManager的实现分析"><a href="#3-AFURLSessionManager的实现分析" class="headerlink" title="3 AFURLSessionManager的实现分析"></a>3 AFURLSessionManager的实现分析</h2><p><code>AFURLSessionManager.m</code>文件里面除了有<code>AFURLSessionManager.h</code>定义的各种接口的实现意外，还有处理不同iOS版本下<code>NSRULSession</code>不同的部分，以及多个全局<code>dispatch_queue_t</code>的定义、以及处理<code>NSURLSeesionTash</code>的各种代理方法的实现和处理。具体划分如下：</p>
<ul>
<li><code>NSURLSessionManager</code>的实现。主要实现了接口文件定义的各种api的实现，比如Task的创建、Task的获取、Task的各种代理方法的实现、NSCoping和NSCoding协议、以及各种Block的实现。<ul>
<li>基本属性的初始化。比如<code>sessionConfiguration</code>、<code>operationQueue</code>、<code>session</code>、<code>mutableTaskDelegatesKeyedByTaskIdentifier</code>等属性。以及用于实现task和<code>AFURLSessionManagerTaskDelegate</code>的绑定的<code>taskDescriptionForSessionTasks</code>、还有关键操作的锁属性lock。</li>
<li>接口文件的各种Block对应的属性，一个Block对应一个属性。</li>
<li>处理Task暂停与重启操作的方法。</li>
<li>给Task设置<code>AFURLSessionManagerTaskDelegate</code>代理的方法。</li>
<li>初始化Task的各种方法。</li>
<li>设置B接口文件定义的各种Block。</li>
<li><code>NSURLSession</code>系列代理方法。</li>
</ul>
</li>
<li><code>_AFURLSessionTaskSwizzling</code>私有类。主要实现了iOS7和iOS8系统上<code>NSURLSession</code>差别的处理。让不同系统版本<code>NSURLSession</code>版本基本一致。</li>
<li><code>AFURLSessionManagerTaskDelegate</code>这个类主要是把<code>NSURLSeesion</code>的部分代理方法让他处理。从而达到简化代码的目的。<ul>
<li>处理Task的上传或者下载进度。</li>
<li>处理封装<code>NSURLSeesion</code>返回的数据。</li>
<li>Task完成等的通知封装。</li>
</ul>
</li>
<li>全局<code>dispatch_queue_t</code>和<code>dispatch_group_t</code>的定义。各种通知名称的初始化，各种Block的类型定义。</li>
</ul>
<h4 id="3-1-AFURLSessionManager一个网络请求实现过程"><a href="#3-1-AFURLSessionManager一个网络请求实现过程" class="headerlink" title="3.1 AFURLSessionManager一个网络请求实现过程"></a>3.1 AFURLSessionManager一个网络请求实现过程</h4><p>我们通过一个网络请求过程来分析<code>AFURLSessionManager.m</code>的实现。我们通过<code>initWithSessionConfiguration</code>方法初始化一个manager。在这个方法里会初始化各种属性、以及为session属性设置代理：</p>
<p>接口文件中的代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</span><br></pre></td></tr></table></figure>
<p>实现文件中对应的处理如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 初始化方法</span></span><br><span class="line"><span class="comment"> @return 返回一个manager对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithSessionConfiguration:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 默认初始化方法、通过这个方法来做manager的具体化初始化动作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param configuration NSURLSession的配置</span></span><br><span class="line"><span class="comment"> @return 返回一个manager对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果用户没有手动指定，则使用默认的configuration来初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">        configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//赋值给属性</span></span><br><span class="line">    <span class="keyword">self</span>.sessionConfiguration = configuration;</span><br><span class="line">    <span class="comment">//初始化NSURLSession的task代理方法执行的队列。</span></span><br><span class="line">    <span class="comment">//这里有一个很关键的点是task的代理执行的queque一次性只能执行一个task。这样就避免了task的代理方法执行的混乱。</span></span><br><span class="line">    <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//出丝滑NSURLSession对象，最核心的对象。</span></span><br><span class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line">    <span class="comment">//如果用户没有手动指定，则返回的数据是JSON格式序列化。</span></span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line">    <span class="comment">//指定https处理的安全策略。</span></span><br><span class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_WATCH</span></span><br><span class="line">    <span class="comment">//初始化网络状态监听属性</span></span><br><span class="line">    <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//用于记录Task与他的`AFURLSessionManagerTaskDelegate`代理对象的一一对应关系。通过这个</span></span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    <span class="comment">//初始化一个锁对象,关键操作加锁。</span></span><br><span class="line">    <span class="keyword">self</span>.lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.lock.name = AFURLSessionManagerLockName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     获取当前session正在执行的所有Task。同时为每一个Task添加`AFURLSessionManagerTaskDelegate`代理对象，这个代理对象主要用于管理uplaodTak和downloadTask的进度管理。并且在Task执行完毕以后调用相应的Block。同时发送相应的notification对象，实现对task数据或者状态改变的检测。</span></span><br><span class="line"><span class="comment">     @param dataTasks dataTask列表</span></span><br><span class="line"><span class="comment">     @param uploadTasks uplaodTask列表</span></span><br><span class="line"><span class="comment">     @param downloadTasks downloadTask列表</span></span><br><span class="line"><span class="comment">     @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDataTask</span> *task <span class="keyword">in</span> dataTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForDataTask:task uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionUploadTask</span> *uploadTask <span class="keyword">in</span> uploadTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDownloadTask</span> *downloadTask <span class="keyword">in</span> downloadTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:<span class="literal">nil</span> destination:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求执行，接口文件如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [manager downloadTaskWithRequest:request progress:^(<span class="built_in">NSProgress</span> *downloadProgress)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载进度:%lld"</span>,downloadProgress.completedUnitCount);</span><br><span class="line">&#125; destination:^<span class="built_in">NSURL</span> *(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response) &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *documentsDirectoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">NO</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"fileURL:%@"</span>,[fileURL absoluteString]);</span><br><span class="line">    <span class="keyword">return</span> fileURL;</span><br><span class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">self</span>.imageView.image = [<span class="built_in">UIImage</span> imageWithData:[<span class="built_in">NSData</span> dataWithContentsOfURL:filePath]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"File downloaded to: %@"</span>, filePath);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>实现文件则调用了很多方法：</p>
<p>1 首先是初始化一个<code>NSURLSessionDownLoadTask</code>对象</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过session创建一个downloadTask，</span></span><br><span class="line">__block <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">//url_session_manager_create_task_safely作用是修复在iOS8下面的系统bug。</span></span><br><span class="line">url_session_manager_create_task_safely(^&#123;</span><br><span class="line">    downloadTask = [<span class="keyword">self</span>.session downloadTaskWithRequest:request];</span><br><span class="line">&#125;);</span><br><span class="line">[<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler];</span><br><span class="line"><span class="keyword">return</span> downloadTask;</span><br></pre></td></tr></table></figure>
<p>2 通过<code>[self addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler];</code>这句话来为Task设置一个<code>AFURLSessionManagerTaskDelegate</code>代理对象。从而可以实现对进度处理、Block调用、Task完成返回数据的拼装的功能。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据指定的Task，初始化一个AFURLSessionManagerTaskDelegate</span></span><br><span class="line">AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:downloadTask];</span><br><span class="line">delegate.manager = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">//设置Task完成的回调Block</span></span><br><span class="line">delegate.completionHandler = completionHandler;</span><br><span class="line"><span class="keyword">if</span> (destination) &#123;</span><br><span class="line">    <span class="comment">//任务完成以后，调用destination这个Block</span></span><br><span class="line">    delegate.downloadTaskDidFinishDownloading = ^<span class="built_in">NSURL</span> * (<span class="built_in">NSURLSession</span> * __unused session, <span class="built_in">NSURLSessionDownloadTask</span> *task, <span class="built_in">NSURL</span> *location) &#123;</span><br><span class="line">        <span class="keyword">return</span> destination(location, task.response);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定Task与taskDescriptionForSessionTasks的关联关系，方便后面的通知中做对应的处理。</span></span><br><span class="line">downloadTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line"><span class="comment">//添加通知</span></span><br><span class="line">[<span class="keyword">self</span> setDelegate:delegate forTask:downloadTask];</span><br><span class="line"><span class="comment">//设置一个下载进度的Block，以便在后面代理方法中调用。</span></span><br><span class="line">delegate.downloadProgressBlock = downloadProgressBlock;</span><br></pre></td></tr></table></figure>
<p>3 初始化一个AFURLSessionManagerTaskDelegate对象。在这个对象中对Task的请求过程进行处理和控制。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 初始化一个AFURLSessionManagerTaskDelegate对象</span></span><br><span class="line"><span class="comment"> @param task 对象绑定的Task</span></span><br><span class="line"><span class="comment"> @return 返回对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个属性用于存储Task下载过程中的数据</span></span><br><span class="line">    _mutableData = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    <span class="comment">//存储Task上传和下载的进度</span></span><br><span class="line">    _uploadProgress = [[<span class="built_in">NSProgress</span> alloc] initWithParent:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    _downloadProgress = [[<span class="built_in">NSProgress</span> alloc] initWithParent:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    __<span class="keyword">weak</span> __typeof__(task) weakTask = task;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSProgress</span> *progress <span class="keyword">in</span> @[ _uploadProgress, _downloadProgress ])</span><br><span class="line">    &#123;</span><br><span class="line">        progress.totalUnitCount = <span class="built_in">NSURLSessionTransferSizeUnknown</span>;</span><br><span class="line">        progress.cancellable = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">//当progress对象取消的时候，取消Task</span></span><br><span class="line">        progress.cancellationHandler = ^&#123;</span><br><span class="line">            [weakTask cancel];</span><br><span class="line">        &#125;;</span><br><span class="line">        progress.pausable = <span class="literal">YES</span>;</span><br><span class="line">        progress.pausingHandler = ^&#123;</span><br><span class="line">            <span class="comment">//挂起Task</span></span><br><span class="line">            [weakTask suspend];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> ([progress respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">            progress.resumingHandler = ^&#123;</span><br><span class="line">                <span class="comment">//重启Task</span></span><br><span class="line">                [weakTask resume];</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更具progress的进度来获取Task的进度。fractionCompleted方法在请求过程中多次执行。</span></span><br><span class="line">        [progress addObserver:<span class="keyword">self</span></span><br><span class="line">                   forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                      options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                      context:<span class="literal">NULL</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面通过对fractionCompleted方法KVO。则会调用下面的方法，从而执行manager的</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">   <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.downloadProgress]) &#123;</span><br><span class="line">       <span class="comment">//更新下载进度Block</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.uploadProgress]) &#123;</span><br><span class="line">        <span class="comment">//更新上传进度Bloc</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.uploadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 在<code>AFURLSessionManagerTaskDelegate</code>设置Task状态改变的监听。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 设置指定task的`AFURLSessionManagerTaskDelegate`对象。并且添加task挂起或者重启的监听。</span></span><br><span class="line"><span class="comment"> @param delegate 代理对象</span></span><br><span class="line"><span class="comment"> @param task task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(delegate);</span><br><span class="line">    <span class="comment">//加锁操作</span></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="comment">//为Task设置与之代理方法关联关系。通过一个字典</span></span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    <span class="comment">//添加对Task开始、重启、挂起状态的通知的接收。</span></span><br><span class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 给Task添加任务开始、重启、挂起的通知</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param task 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)addNotificationObserverForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5 从下面开始，任务就正式开始执行。其实就是<code>[downloadTask resume];</code>执行以后开始。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在网络请求正式开始以后，这个方法会在数据接收的过程中多次调用。我们可以通过这个方法获取数据下载的大小、总得大小、还有多少么有下载</span></span><br><span class="line"><span class="comment"> @param session session</span></span><br><span class="line"><span class="comment"> @param downloadTask 对应的Task</span></span><br><span class="line"><span class="comment"> @param bytesWritten 已经下载的字节</span></span><br><span class="line"><span class="comment"> @param totalBytesWritten 总的字节大小</span></span><br><span class="line"><span class="comment"> @param totalBytesExpectedToWrite nil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">      didWriteData:(int64_t)bytesWritten</span><br><span class="line"> totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取Task对应的`AFURLSessionManagerTaskDelegate`对象。从而可以调用对应的代理方法</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:downloadTask];</span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        <span class="comment">//调用`AFURLSessionManagerTaskDelegate`类中的代理方法。从而实现对于进度更新等功能。</span></span><br><span class="line">        <span class="comment">//会调用下面的那个方法</span></span><br><span class="line">        [delegate URLSession:session downloadTask:downloadTask didWriteData:bytesWritten totalBytesWritten:totalBytesWritten totalBytesExpectedToWrite:totalBytesExpectedToWrite];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidWriteData) &#123;</span><br><span class="line">        <span class="comment">//如果有`downloadTaskDidWriteData`Block的实现，则在这个调用Block从而实现对下载进度过程的控制。</span></span><br><span class="line">        <span class="keyword">self</span>.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AFURLSessionManagerTaskDelegate里面的这个代理方法实现对进度的更新。</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">      didWriteData:(int64_t)bytesWritten</span><br><span class="line"> totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123;</span><br><span class="line">    <span class="comment">//AFURLSessionManagerTaskDelegate代理方法实现对下载进度的记录</span></span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.totalUnitCount = totalBytesExpectedToWrite;</span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.completedUnitCount = totalBytesWritten;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6 Task完成以后，会调用<code>AFURLSessionManagerTaskDelegate</code>对象的方法对返回的数据封装。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AFURLSessionManagerTaskDelegate里面的这个代理方法实现对数据的具体处理。</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取Task对应的manager对象</span></span><br><span class="line">    __<span class="keyword">strong</span> AFURLSessionManager *manager = <span class="keyword">self</span>.manager;</span><br><span class="line">    <span class="comment">//要封装的responseObject对象。</span></span><br><span class="line">    __block <span class="keyword">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line">    __block <span class="built_in">NSMutableDictionary</span> *userInfo = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line">    <span class="comment">//返回的数据。</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.mutableData) &#123;</span><br><span class="line">        data = [<span class="keyword">self</span>.mutableData <span class="keyword">copy</span>];</span><br><span class="line">        <span class="comment">//We no longer need the reference, so nil it out to gain back some memory.</span></span><br><span class="line">        <span class="keyword">self</span>.mutableData = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是downloadTask，则封装downloadFileURL</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data) &#123;<span class="comment">//如果是其他Task，则封装返回的data。</span></span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有错封装</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="comment">//如果Task有completionHandler。则调用这个Block</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                <span class="keyword">self</span>.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送一个指定Task结束的通知</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//正确数据封装</span></span><br><span class="line">        <span class="comment">//在一个并行的dispat_queuq_t对象里面异步处理。</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">            <span class="comment">//封装responseBojct</span></span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">                responseObject = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="comment">//如果Task有完成Block。则调用这个Block</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//发送通知</span></span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7 移除Task对应的通知和对应的<code>AFURLSessionManagerTaskDelegate</code>代理对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeDelegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="comment">//移除Task对应的通知</span></span><br><span class="line">    [<span class="keyword">self</span> removeNotificationObserverForTask:task];</span><br><span class="line">    <span class="comment">//移除Task对应的`AFURLSessionManagerTaskDelegate`代理对象。</span></span><br><span class="line">    [<span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除通知监听</span></span><br><span class="line">- (<span class="keyword">void</span>)removeNotificationObserverForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span> name:AFNSURLSessionTaskDidSuspendNotification object:task];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span> name:AFNSURLSessionTaskDidResumeNotification object:task];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//`AFURLSessionManagerTaskDelegate`对象回收。</span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress removeObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress removeObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的过程，我们发现核心流程都是围绕了<code>NSRULSessionTask</code>对象以及与之绑定的<code>AFURLSessionManagerTaskDelegate</code>对象执行的。我们通过在<code>NSRULSessionTask</code>对象的代理方法里面手动调用<code>AFURLSessionManagerTaskDelegate</code>对应的代理方法来实现对数据的处理和简化代码的作用，这个设计思路的确吊吊的。还有一些方法没有涉及到，不过大同小异，基本过程就是这样，就不一一解释了。</p>
<h4 id="3-2-AFURLSessionManager一些特殊模块的说明"><a href="#3-2-AFURLSessionManager一些特殊模块的说明" class="headerlink" title="3.2 AFURLSessionManager一些特殊模块的说明"></a>3.2 AFURLSessionManager一些特殊模块的说明</h4><p><code>AFURLSeeesionManager</code>实现了<code>NSSecureCoding</code>协议。让manager可以归档解档。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在iOS8以及以上环境下，supportsSecureCoding必须重写并且返回true。</span></span><br><span class="line"><span class="comment"> @return bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)supportsSecureCoding &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解档</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)decoder &#123;</span><br><span class="line">    <span class="built_in">NSURLSessionConfiguration</span> *configuration = [decoder decodeObjectOfClass:[<span class="built_in">NSURLSessionConfiguration</span> <span class="keyword">class</span>] forKey:<span class="string">@"sessionConfiguration"</span>];</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> initWithSessionConfiguration:configuration];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 我们发现对象归档的时候，只归档了`NSURLSessionConfiguration`属性。所以说归档接档的时候所有Block设置、operation设置都会失效。</span></span><br><span class="line"><span class="comment"> @param coder coder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)coder &#123;</span><br><span class="line">    [coder encodeObject:<span class="keyword">self</span>.session.configuration forKey:<span class="string">@"sessionConfiguration"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，<code>AFURLSessionManager</code>也实现了<code>NSCopying</code>协议。通过协议的实现过程，我们发现也是只使用了<code>NSURLSessionConfiguration</code>属性。和归档解档一样。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 实现NSCopying协议。copy的NAURLSessionManager没有复制任何与代理处理相关的Block</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] initWithSessionConfiguration:<span class="keyword">self</span>.session.configuration];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有的时候，我们的请求会返回302这个状态码，这个表示需要请求重定向到另一个url，我们可以下面这个代理方法里面决定对于重定向的处理,如果对<code>completionHandler</code>传入nil,则会把response传入重定向请求。另外，backgroundSession的Task不会调用下面这个代理方法，而是直接调用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 有的时候，我们的请求会返回302这个状态码，这个表示需要请求重定向到另一个url，我们可以在这个代理方法里面绝定对于重定向的处理。</span></span><br><span class="line"><span class="comment"> @param session session</span></span><br><span class="line"><span class="comment"> @param task task</span></span><br><span class="line"><span class="comment"> @param response response</span></span><br><span class="line"><span class="comment"> @param request 重定向的request。</span></span><br><span class="line"><span class="comment"> @param completionHandler 请求完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task willPerformHTTPRedirection:(<span class="built_in">NSHTTPURLResponse</span> *)response newRequest:(<span class="built_in">NSURLRequest</span> *)request completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重定向的request对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *redirectRequest = request;</span><br><span class="line">    <span class="comment">//如果用户指定了taskWillPerformHTTPRedirection这个Block,我们就通过这个Block的调用返回处理完成的request对象。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskWillPerformHTTPRedirection) &#123;</span><br><span class="line">        redirectRequest = <span class="keyword">self</span>.taskWillPerformHTTPRedirection(session, task, response, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个调用是必须的，执行重定向操作。</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(redirectRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建<code>NSRULSessionUplaodTask</code>的时候，在某些系统上会出现bug。AFN已经帮我们处理好：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromFile:(<span class="built_in">NSURL</span> *)fileURL progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLSessionUploadTask</span> *uploadTask = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//用线程安全的方式创建一个dataTask。修复iOS8下面的bug。</span></span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        uploadTask = [<span class="keyword">self</span>.session uploadTaskWithRequest:request fromFile:fileURL];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//用于处理uploadTask在iOS7环境下面有可能创建失败的情况。如果attemptsToRecreateUploadTasksForBackgroundSessions为true。则尝试重新创建Task。如果三次都没有成功，则放弃。</span></span><br><span class="line">    <span class="keyword">if</span> (!uploadTask &amp;&amp; <span class="keyword">self</span>.attemptsToRecreateUploadTasksForBackgroundSessions &amp;&amp; <span class="keyword">self</span>.session.configuration.identifier) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> attempts = <span class="number">0</span>; !uploadTask &amp;&amp; attempts &lt; AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask; attempts++) &#123;</span><br><span class="line">            uploadTask = [<span class="keyword">self</span>.session uploadTaskWithRequest:request fromFile:fileURL];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为Task添加`AFURLSessionManagerTaskDelegate`代理方法</span></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler];</span><br><span class="line">    <span class="keyword">return</span> uploadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用<code>dispatch_semaphore_t</code>来控制对异步处理返回结果的控制。非常有借鉴意义。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -  获取当前session对应的task列表。通过dispatch_semaphore_t来控制访问过程。</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)tasksForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    __block <span class="built_in">NSArray</span> *tasks = <span class="literal">nil</span>;</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(dataTasks))]) &#123;</span><br><span class="line">            tasks = dataTasks;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(uploadTasks))]) &#123;</span><br><span class="line">            tasks = uploadTasks;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(downloadTasks))]) &#123;</span><br><span class="line">            tasks = downloadTasks;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(tasks))]) &#123;</span><br><span class="line">            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:<span class="string">@"@unionOfArrays.self"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里发送一个信号量，让semaphore变为1。此时表示tasks已经成功获取。</span></span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//这里会一直等待信号量变为1。</span></span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="comment">//返回Task。通过信号量控制，避免了方法结束的时候，tasks还没有正常获取的情况。</span></span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-AFURLSessionTaskSwizzling私有类的说明"><a href="#4-AFURLSessionTaskSwizzling私有类的说明" class="headerlink" title="4 _AFURLSessionTaskSwizzling私有类的说明"></a>4 _AFURLSessionTaskSwizzling私有类的说明</h2><p>在iOS7和iOS8及以上的系统，<code>NSRULSessionTask</code>的具体实现是不同的。我们目前知道的不同有:</p>
<ul>
<li><code>NSURLSessionTasks</code>是一个类簇。所以我们初始化一个Task的时候，我们并不只到初始化的到底是哪个子类。</li>
<li>简单的通过<code>[NSURLSessionTask class]</code>并不会起作用。必须通过<code>NSURLSession</code>创建一个task对象。然后获取他所在的类。</li>
<li>iOS7下面,下面代码中的<code>localDataTask</code>对象的继承关系是<code>__NSCFLocalDataTask</code> -&gt; <code>__NSCFLocalSessionTask</code> -&gt; <code>__NSCFURLSessionTask</code>。</li>
<li>在iOS8以及以上系统。下面代码中的<code>localDataTask</code>对象的继承关系是<code>__NSCFLocalDataTask</code> -&gt; <code>__NSCFLocalSessionTask</code> -&gt; <code>NSURLSessionTask</code>。</li>
<li>在iOS7下面<code>__NSCFLocalSessionTask</code>和<code>__NSCFURLSessionTask</code>实现了<code>resume</code>和<code>suspend</code>方法，同时最重要的是他不调用父类的实现。但是iOS8下面，只有<code>NSURLSessionTask</code>实现了<code>resume</code>和<code>suspend</code>。所以在iOS7的环境下，我们需要想办法让<code>resume</code>和<code>suspend</code>调用<code>NSURLSessionTask</code>的具体实现。</li>
</ul>
<p>下面的代码完美的向我们展示了一个向类添加方法，并且swizzle方法实现的过程。值得仔细琢磨。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 切换theClass类的`originalSelector`和`swizzledSelector`的实现</span></span><br><span class="line"><span class="comment"> @param theClass 类</span></span><br><span class="line"><span class="comment"> @param originalSelector 方法一</span></span><br><span class="line"><span class="comment"> @param swizzledSelector 方法2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 动态给一个类添加方法</span></span><br><span class="line"><span class="comment"> @param theClass 类</span></span><br><span class="line"><span class="comment"> @param selector 方法名字</span></span><br><span class="line"><span class="comment"> @param method 方法体</span></span><br><span class="line"><span class="comment"> @return bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">BOOL</span> af_addMethod(Class theClass, SEL selector, Method method) &#123;</span><br><span class="line">    <span class="keyword">return</span> class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_AFURLSessionTaskSwizzling</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@"NSURLSessionTask"</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</span><br><span class="line">        <span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic ignored <span class="meta-string">"-Wnonnull"</span></span></span><br><span class="line">        <span class="comment">//初始化一个dataTask对象</span></span><br><span class="line">        <span class="built_in">NSURLSessionDataTask</span> *localDataTask = [session dataTaskWithURL:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        <span class="comment">//获取af_resume这个方法的实现。</span></span><br><span class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(af_resume)));</span><br><span class="line">        <span class="comment">//获取dataTask的具体类</span></span><br><span class="line">        Class currentClass = [localDataTask <span class="keyword">class</span>];</span><br><span class="line">        <span class="comment">//如果父类有resume方法。则改变方法的具体实现。</span></span><br><span class="line">        <span class="keyword">while</span> (class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume))) &#123;</span><br><span class="line">            Class superClass = [currentClass superclass];</span><br><span class="line">            <span class="comment">//找到类和父类的resume方法实现</span></span><br><span class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line">            <span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp;</span><br><span class="line">                originalAFResumeIMP != classResumeIMP) &#123;</span><br><span class="line">                <span class="comment">//添加方法、然后转换方法的实现</span></span><br><span class="line">                [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class="line">            &#125;</span><br><span class="line">            currentClass = [currentClass superclass];</span><br><span class="line">        &#125;</span><br><span class="line">        [localDataTask cancel];</span><br><span class="line">        [session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 主要是实现了为一个类添加方法、并且转换添加方法和原来对应方法的实现。</span></span><br><span class="line"><span class="comment"> @param theClass 要操作的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</span><br><span class="line">    Method afResumeMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_resume));</span><br><span class="line">    Method afSuspendMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_suspend));</span><br><span class="line">    <span class="comment">//为theClass类添加一个af_resume方法。</span></span><br><span class="line">    <span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_resume), afResumeMethod)) &#123;</span><br><span class="line">        <span class="comment">//把dataTask的resume和afresume方法的实现互换。</span></span><br><span class="line">        af_swizzleSelector(theClass, <span class="keyword">@selector</span>(resume), <span class="keyword">@selector</span>(af_resume));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为theClass类添加一个af_suspend方法</span></span><br><span class="line">    <span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_suspend), afSuspendMethod)) &#123;</span><br><span class="line">        <span class="comment">//把dataTask的suspend和af_suspend方法的实现互换。</span></span><br><span class="line">        af_swizzleSelector(theClass, <span class="keyword">@selector</span>(suspend), <span class="keyword">@selector</span>(af_suspend));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSURLSessionTaskState</span>)state &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@"State method should never be called in the actual dummy class"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSURLSessionTaskStateCanceling</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在iOS7下面，`NSURLSessionDataTask`调用resume方法其实就是执行`af_resume`的具体实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)af_resume &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@"Does not respond to state"</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    <span class="comment">//这里其实就是调用dataTask的resume实现</span></span><br><span class="line">    [<span class="keyword">self</span> af_resume];</span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateRunning</span>) &#123;</span><br><span class="line">        <span class="comment">//这里的self其实就是`NSRULSessionDataTask`对象</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在iOS7下面，`NSURLSessionDataTask`调用suspend方法其实就是执行`af_suspend`的具体实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)af_suspend &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@"Does not respond to state"</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    <span class="comment">//这里其实就是调用dataTask的suspend具体实现</span></span><br><span class="line">    [<span class="keyword">self</span> af_suspend];</span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">        <span class="comment">//这里的self其实就是`NSRULSessionDataTask`对象</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p><code>AFURLSessionManager</code>通过对task设置一个<code>AFURLSessionManagerTaskDelegate</code>代理来处理繁杂的请求进度管理。从而降低了代码的负责度。是代理模式的一个很好的实践。</p>
<p><code>AFURLSessionManager</code>通过私有类<code>_AFURLSessionTaskSwizzling</code>来修改iOS7和iOS8系统上面不同。是对于方法swizzle的一个成功和完整的实践。</p>
<p><code>AFURLSessionManager</code>通过添加各种Block，让我们对请求过程有全方位的控制和处理。同时提供简洁的api，把负责的处理全部封装好。</p>
<p>具体源码在<a href="https://github.com/huang303513/iOSSourceCodeStudy">iOSSourceCodeStudy</a>。</p>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2017/04/20/AFNetWorking源码之AFHTTPSessionManager/" data-toggle="tooltip" data-placement="top" title="AFNetWorking源码之AFHTTPSessionManager">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2017/04/15/UIViewController和UIView不同加载方式的生命周期函数/" data-toggle="tooltip" data-placement="top" title="UIViewController和UIView不同加载方式的生命周期函数">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <!-- tip end -->

                <!-- Music start-->
                
                
<link rel="stylesheet" href="/css/music-player/fonts/iconfont.css">


<link rel="stylesheet" href="/css/music-player/css/reset.css">


<link rel="stylesheet" href="/css/music-player/css/player.css">


<div class="music-player">
    <audio class="music-player__audio" ></audio>
    <div class="music-player__main">
        <div class="music-player__blur"></div>
        <div class="music-player__disc">
            <div class="music-player__image">
                <img width="100%" src="" alt="">
            </div>
            <div class="music-player__pointer"><img width="100%" src="/img/cd_tou.png" alt=""></div>
        </div>
        <div class="music-player__controls">
            <div class="music__info">
                <h3 class="music__info--title">...</h3>
                <p class="music__info--singer">...</p>
            </div>
            <div class="player-control">
                <div class="player-control__content">
                    <div class="player-control__btns">
                        <div class="player-control__btn player-control__btn--prev"><i class="iconfont icon-prev"></i></div>
                        <div class="player-control__btn player-control__btn--play"><i class="iconfont icon-play"></i></div>
                        <div class="player-control__btn player-control__btn--next"><i class="iconfont icon-next"></i></div>
                        <div class="player-control__btn player-control__btn--mode"><i class="iconfont icon-loop"></i></div>
                    </div>
                    <div class="player-control__volume">
                        <div class="control__volume--icon player-control__btn"><i class="iconfont icon-volume"></i></div>
                        <div class="control__volume--progress player_progress"></div>
                    </div>
                </div>
                <div class="player-control__content">
                    <div class="player__song--progress player_progress"></div>
                    <div class="player__song--timeProgess nowTime">00:00</div>
                    <div class="player__song--timeProgess totalTime">00:00</div>
                </div>
            </div>
        </div>
    </div>
</div>


<script src="/js/music-player/utill.js"></script>


<script src="/js/music-player/jquery.min.js"></script>


<script src="/js/music-player/player.js"></script>


                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      
        <aside id="sidebar">
          <div id="toc" class="toc-article">
          <strong class="toc-title">Contents</strong>
          
            
              <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-概述"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">1 概述</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-AFURLSessionManager的声明分析"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">2 AFURLSessionManager的声明分析</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-AFURLSessionManager的初始化api"><span class="toc-nav-number">2.0.1.</span> <span class="toc-nav-text">2.1 AFURLSessionManager的初始化api</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-AFURLSessionManager获取Task的api"><span class="toc-nav-number">2.0.2.</span> <span class="toc-nav-text">2.2 AFURLSessionManager获取Task的api</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-3-AFURLSessionManager为管理Task创建Block"><span class="toc-nav-number">2.0.3.</span> <span class="toc-nav-text">2.3 AFURLSessionManager为管理Task创建Block</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-4-AFURLSessionManager设置各种情况的代理回调"><span class="toc-nav-number">2.0.4.</span> <span class="toc-nav-text">2.4 AFURLSessionManager设置各种情况的代理回调</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-AFURLSessionManager的实现分析"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">3 AFURLSessionManager的实现分析</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-AFURLSessionManager一个网络请求实现过程"><span class="toc-nav-number">3.0.1.</span> <span class="toc-nav-text">3.1 AFURLSessionManager一个网络请求实现过程</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-AFURLSessionManager一些特殊模块的说明"><span class="toc-nav-number">3.0.2.</span> <span class="toc-nav-text">3.2 AFURLSessionManager一些特殊模块的说明</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-AFURLSessionTaskSwizzling私有类的说明"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">4 _AFURLSessionTaskSwizzling私有类的说明</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-总结"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">5 总结</span></a></li></ol>
            
          
          </div>
        </aside>
      
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#AFNetWorking" title="AFNetWorking">AFNetWorking</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>






    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                
                    <li>
                        <a target="_blank"  href="https://github.com/huang303513">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 黄成都 2020 
                    <br>
                    Powered by 
                    <a href="https://github.com/dusign/hexo-theme-snail">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=dusign&repo=hexo-theme-snail&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>


<!-- Search -->

<script src="/js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://github.com/huang303513/huang303513.github.io.git/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&quot;🌱&quot;,&quot;just do it&quot;,&quot;🍀&quot;]' color='[&quot;rgb(121,93,179)&quot; ,&quot;rgb(76,180,231)&quot; ,&quot;rgb(184,90,154)&quot;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
